"""
Execution logger for saving CLI execution summaries as markdown files
"""

import os
import json
from datetime import datetime
from typing import Dict, Any, Optional
import structlog

logger = structlog.get_logger()

class ExecutionLogger:
    """Logger for saving CLI execution summaries as markdown files"""

    def __init__(self, logs_dir: str = "execution_logs"):
        self.logs_dir = logs_dir
        self._ensure_logs_directory()

    def _ensure_logs_directory(self):
        """Ensure the logs directory exists"""
        if not os.path.exists(self.logs_dir):
            os.makedirs(self.logs_dir)
            logger.info("execution_logs_directory_created", directory=self.logs_dir)

    def _generate_filename(self, operation: str) -> str:
        """Generate filename in format yyyy-mm-dd_glm-summary-title"""
        date_str = datetime.now().strftime("%Y-%m-%d")

        # Clean operation name for filename
        clean_operation = (
            operation.lower()
            .replace(" ", "-")
            .replace(",", "")
            .replace(".", "")
            .replace(":", "")
            .replace("é", "e")
            .replace("è", "e")
            .replace("ê", "e")
            .replace("à", "a")
            .replace("â", "a")
            .replace("î", "i")
            .replace("ô", "o")
            .replace("û", "u")
            .replace("ç", "c")
        )

        # Limit filename length
        if len(clean_operation) > 60:
            clean_operation = clean_operation[:57] + "..."

        return f"{date_str}_glm-{clean_operation}.md"

    def save_execution_summary(
        self,
        operation: str,
        status: str,
        duration: str,
        key_results: list,
        next_steps: list,
        technical_details: Optional[Dict[str, Any]] = None,
        error_message: Optional[str] = None
    ) -> str:
        """Save execution summary as markdown file"""

        filename = self._generate_filename(operation)
        filepath = os.path.join(self.logs_dir, filename)

        # Create markdown content
        content = self._generate_markdown_content(
            operation=operation,
            status=status,
            duration=duration,
            key_results=key_results,
            next_steps=next_steps,
            technical_details=technical_details,
            error_message=error_message
        )

        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)

            logger.info("execution_summary_saved", filename=filename, operation=operation)
            return filepath

        except Exception as e:
            logger.error("failed_to_save_execution_summary", filename=filename, error=str(e))
            return ""

    def _generate_markdown_content(
        self,
        operation: str,
        status: str,
        duration: str,
        key_results: list,
        next_steps: list,
        technical_details: Optional[Dict[str, Any]] = None,
        error_message: Optional[str] = None
    ) -> str:
        """Generate markdown content for execution summary"""

        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Status emoji
        status_emoji = {
            "success": "✅",
            "partial": "⚠️",
            "failed": "❌",
            "error": "❌"
        }.get(status.lower(), "📋")

        content = f"""# {status_emoji} {operation}

## 📊 Execution Summary
- **Timestamp:** {timestamp}
- **Status:** {status.title()}
- **Duration:** {duration}
- **CLI Session:** Gust-IA Assistant

## 🎯 Key Results
"""

        # Add key results
        for i, result in enumerate(key_results, 1):
            content += f"{i}. {result}\n"

        content += "\n## 📈 Next Steps\n"

        # Add next steps
        for i, step in enumerate(next_steps, 1):
            content += f"{i}. {step}\n"

        # Add technical details if provided
        if technical_details:
            content += "\n## 🔧 Technical Details\n"
            for key, value in technical_details.items():
                if isinstance(value, list):
                    content += f"- **{key}:**\n"
                    for item in value:
                        content += f"  - {item}\n"
                elif isinstance(value, dict):
                    content += f"- **{key}:**\n"
                    for sub_key, sub_value in value.items():
                        content += f"  - {sub_key}: {sub_value}\n"
                else:
                    content += f"- **{key}:** {value}\n"

        # Add error message if provided
        if error_message:
            content += f"\n## ❌ Error Details\n```\n{error_message}\n```"

        content += f"\n---\n\n*Generated by Gust-IA CLI Assistant*\n*Service Diocésain de la Catéchèse*"

        return content

    def save_from_waha_summary(self, summary_text: str) -> str:
        """Parse WAHA summary text and save as markdown"""
        try:
            # Parse the WAHA summary format
            lines = summary_text.split('\n')

            operation = ""
            status = "unknown"
            duration = "unknown"
            key_results = []
            next_steps = []
            technical_details = {}

            current_section = None

            for line in lines:
                line = line.strip()

                if line.startswith("Operation:"):
                    operation = line.replace("Operation:", "").strip()
                elif line.startswith("Status:"):
                    status = line.replace("Status:", "").strip()
                elif line.startswith("Duration:"):
                    duration = line.replace("Duration:", "").strip()
                elif line.startswith("Key Results:"):
                    current_section = "key_results"
                elif line.startswith("Next Steps:"):
                    current_section = "next_steps"
                elif line.startswith("Technical Fixes:"):
                    current_section = "technical_fixes"
                elif line.startswith("•"):
                    content = line.replace("•", "").strip()
                    if current_section == "key_results":
                        key_results.append(content)
                    elif current_section == "next_steps":
                        next_steps.append(content)
                    elif current_section == "technical_fixes":
                        if "technical_fixes" not in technical_details:
                            technical_details["technical_fixes"] = []
                        technical_details["technical_fixes"].append(content)

            if operation:
                return self.save_execution_summary(
                    operation=operation,
                    status=status,
                    duration=duration,
                    key_results=key_results,
                    next_steps=next_steps,
                    technical_details=technical_details if technical_details else None
                )
            else:
                logger.warning("could_not_parse_operation_from_summary", summary=summary_text[:100])
                return ""

        except Exception as e:
            logger.error("failed_to_parse_waha_summary", error=str(e))
            return ""

# Global instance
execution_logger = ExecutionLogger()

def save_execution_summary_auto(
    operation: str,
    status: str,
    duration: str,
    key_results: list,
    next_steps: list,
    technical_details: Optional[Dict[str, Any]] = None,
    error_message: Optional[str] = None
) -> str:
    """Auto-save execution summary - call this at the end of each CLI operation"""
    return execution_logger.save_execution_summary(
        operation=operation,
        status=status,
        duration=duration,
        key_results=key_results,
        next_steps=next_steps,
        technical_details=technical_details,
        error_message=error_message
    )

def save_waha_summary_auto(summary_text: str) -> str:
    """Auto-save WhatsApp summary - call this after sending WhatsApp notifications"""
    return execution_logger.save_from_waha_summary(summary_text)

def save_whatsapp_summary_auto(summary_text: str) -> str:
    """Auto-save WhatsApp summary - alias for save_waha_summary_auto"""
    return execution_logger.save_from_waha_summary(summary_text)